import { saveCurrentConfig } from './use.js';
import { EmptyApp, getAppScopes, isCurrentAppSchema, isLegacyAppSchema, } from '../../../models/app/app.js';
import { selectConfigName } from '../../../prompts/config.js';
import { getAppConfigurationFileName, loadApp } from '../../../models/app/loader.js';
import { InvalidApiKeyErrorMessage, fetchOrCreateOrganizationApp, logMetadataForLoadedContext } from '../../context.js';
import { fetchAppDetailsFromApiKey, fetchAppExtensionRegistrations } from '../../dev/fetch.js';
import { configurationFileNames } from '../../../constants.js';
import { writeAppConfigurationFile } from '../write-app-configuration-file.js';
import { getCachedCommandInfo } from '../../local-storage.js';
import { fetchPartnersSession } from '../../context/partner-account-info.js';
import { fetchSpecifications } from '../../generate/fetch-extension-specifications.js';
import { loadFSExtensionsSpecifications } from '../../../models/extensions/load-specifications.js';
import { fetchAppRemoteBetaFlags } from '../select-app.js';
import { renderSuccess } from '@shopify/cli-kit/node/ui';
import { AbortError } from '@shopify/cli-kit/node/error';
import { formatPackageManagerCommand } from '@shopify/cli-kit/node/output';
import { deepMergeObjects, isEmpty } from '@shopify/cli-kit/common/object';
import { joinPath } from '@shopify/cli-kit/node/path';
export default async function link(options, shouldRenderSuccess = true) {
    const { token, remoteApp, directory } = await selectRemoteApp(options);
    const { localApp, configFileName, configFilePath } = await loadLocalApp(options, token, remoteApp, directory);
    await logMetadataForLoadedContext(remoteApp);
    let configuration = mergeAppConfiguration({ ...localApp.configuration, path: configFilePath }, remoteApp, localApp.useVersionedAppConfig);
    if (localApp.useVersionedAppConfig) {
        const remoteAppConfigurationFromExtensions = await loadRemoteAppConfigurationFromExtensions(token, remoteApp, localApp);
        configuration = deepMergeObjects(configuration, remoteAppConfigurationFromExtensions);
    }
    await writeAppConfigurationFile(configuration, localApp.configSchema);
    await saveCurrentConfig({ configFileName, directory });
    if (shouldRenderSuccess) {
        renderSuccessMessage(configFileName, remoteApp, localApp, localApp.useVersionedAppConfig);
    }
    return configuration;
}
async function selectRemoteApp(options) {
    const localApp = await loadAppOrEmptyApp(options);
    const directory = localApp?.directory || options.directory;
    const partnersSession = await fetchPartnersSession();
    const remoteApp = await loadRemoteApp(localApp, options.apiKey, partnersSession, directory);
    return {
        token: partnersSession.token,
        remoteApp,
        directory,
    };
}
async function loadLocalApp(options, token, remoteApp, directory) {
    const specifications = await fetchSpecifications({
        token,
        apiKey: remoteApp.apiKey,
        config: options.commandConfig,
    });
    const betas = await fetchAppRemoteBetaFlags(remoteApp.apiKey, token);
    const localApp = await loadAppOrEmptyApp(options, specifications, betas, remoteApp);
    const configFileName = await loadConfigurationFileName(remoteApp, options, localApp);
    const configFilePath = joinPath(directory, configFileName);
    return {
        localApp,
        configFileName,
        configFilePath,
    };
}
async function loadAppOrEmptyApp(options, specifications, remoteBetas, remoteApp) {
    try {
        const app = await loadApp({
            specifications,
            directory: options.directory,
            mode: 'report',
            configName: options.baseConfigName,
            remoteBetas,
        });
        const configuration = app.configuration;
        if (!isCurrentAppSchema(configuration) || remoteApp?.apiKey === configuration.client_id)
            return app;
        return new EmptyApp(await loadFSExtensionsSpecifications(), remoteBetas, remoteApp?.apiKey);
        // eslint-disable-next-line no-catch-all/no-catch-all
    }
    catch (error) {
        return new EmptyApp(await loadFSExtensionsSpecifications(), remoteBetas);
    }
}
async function loadRemoteApp(localApp, apiKey, partnersSession, directory) {
    if (!apiKey) {
        return fetchOrCreateOrganizationApp(localApp, partnersSession, directory);
    }
    const app = await fetchAppDetailsFromApiKey(apiKey, partnersSession.token);
    if (!app) {
        const errorMessage = InvalidApiKeyErrorMessage(apiKey);
        throw new AbortError(errorMessage.message, errorMessage.tryMessage);
    }
    return app;
}
async function loadRemoteAppConfigurationFromExtensions(token, remoteApp, localApp) {
    const remoteExtensionRegistrations = await fetchAppExtensionRegistrations({
        token,
        apiKey: remoteApp.apiKey,
    });
    return remoteAppConfigurationExtensionContent(remoteExtensionRegistrations.app.configurationRegistrations, localApp.specifications ?? []);
}
async function loadConfigurationFileName(remoteApp, options, localApp) {
    const cache = getCachedCommandInfo();
    if (!cache?.askConfigName && cache?.selectedToml)
        return cache.selectedToml;
    if (options.configName) {
        return getAppConfigurationFileName(options.configName);
    }
    if (isLegacyAppSchema(localApp.configuration)) {
        return configurationFileNames.app;
    }
    const configName = await selectConfigName(localApp.directory || options.directory, remoteApp.title);
    return `shopify.app.${configName}.toml`;
}
export function mergeAppConfiguration(appConfiguration, remoteApp, useVersionedAppConfig) {
    return {
        ...addLocalAppConfig(appConfiguration, remoteApp, useVersionedAppConfig),
        ...addBrandingConfig(remoteApp),
        ...addPosConfig(remoteApp),
        ...addRemoteAppWebhooksConfig(remoteApp),
        ...addRemoteAppAccessConfig(appConfiguration, remoteApp),
        ...addRemoteAppProxyConfig(remoteApp),
        ...addRemoteAppHomeConfig(remoteApp),
    };
}
function addRemoteAppHomeConfig(remoteApp) {
    const homeConfig = {
        application_url: remoteApp.applicationUrl.replace(/\/$/, ''),
        embedded: remoteApp.embedded === undefined ? true : remoteApp.embedded,
    };
    return remoteApp.preferencesUrl
        ? {
            ...homeConfig,
            app_preferences: {
                url: remoteApp.preferencesUrl,
            },
        }
        : { ...homeConfig };
}
function addRemoteAppProxyConfig(remoteApp) {
    return remoteApp.appProxy?.url
        ? {
            app_proxy: {
                url: remoteApp.appProxy.url,
                subpath: remoteApp.appProxy.subPath,
                prefix: remoteApp.appProxy.subPathPrefix,
            },
        }
        : {};
}
function addRemoteAppWebhooksConfig(remoteApp) {
    const hasAnyPrivacyWebhook = remoteApp.gdprWebhooks?.customerDataRequestUrl ||
        remoteApp.gdprWebhooks?.customerDeletionUrl ||
        remoteApp.gdprWebhooks?.shopDeletionUrl;
    const privacyComplianceContent = {
        privacy_compliance: {
            customer_data_request_url: remoteApp.gdprWebhooks?.customerDataRequestUrl,
            customer_deletion_url: remoteApp.gdprWebhooks?.customerDeletionUrl,
            shop_deletion_url: remoteApp.gdprWebhooks?.shopDeletionUrl,
        },
    };
    return {
        webhooks: {
            api_version: remoteApp.webhookApiVersion || '2023-07',
            ...(hasAnyPrivacyWebhook ? privacyComplianceContent : {}),
        },
    };
}
function addRemoteAppAccessConfig(appConfiguration, remoteApp) {
    let accessScopesContent = {};
    // if we have upstream scopes, use them
    if (remoteApp.requestedAccessScopes) {
        accessScopesContent = {
            scopes: remoteApp.requestedAccessScopes.join(','),
        };
        // if we can't find scopes or have to fall back, omit setting a scope and set legacy to true
    }
    else if (getAppScopes(appConfiguration) === '') {
        accessScopesContent = {
            use_legacy_install_flow: true,
        };
        // if we have scopes locally and not upstream, preserve them but don't push them upstream (legacy is true)
    }
    else {
        accessScopesContent = {
            scopes: getAppScopes(appConfiguration),
            use_legacy_install_flow: true,
        };
    }
    return {
        auth: {
            redirect_urls: remoteApp.redirectUrlWhitelist,
        },
        access_scopes: accessScopesContent,
    };
}
function addLocalAppConfig(appConfiguration, remoteApp, useVersionedAppConfig) {
    let localAppConfig = {
        ...appConfiguration,
        client_id: remoteApp.apiKey,
    };
    if (isCurrentAppSchema(localAppConfig)) {
        delete localAppConfig.auth;
        const build = {
            ...(useVersionedAppConfig && remoteApp.newApp ? { include_config_on_deploy: true } : {}),
            ...(appConfiguration.client_id === remoteApp.apiKey ? localAppConfig.build : {}),
        };
        if (isEmpty(build)) {
            delete localAppConfig.build;
        }
        else {
            localAppConfig = {
                ...localAppConfig,
                build,
            };
        }
    }
    return localAppConfig;
}
function addPosConfig(remoteApp) {
    return {
        pos: {
            embedded: remoteApp.posEmbedded || false,
        },
    };
}
function addBrandingConfig(remoteApp) {
    return {
        name: remoteApp.title,
    };
}
export function remoteAppConfigurationExtensionContent(configRegistrations, specifications) {
    let remoteAppConfig = {};
    const configSpecifications = specifications.filter((spec) => spec.appModuleFeatures().includes('app_config'));
    configRegistrations.forEach((extension) => {
        const configSpec = configSpecifications.find((spec) => spec.identifier === extension.type.toLowerCase());
        if (!configSpec)
            return;
        const configExtensionString = extension.activeVersion?.config;
        if (!configExtensionString)
            return;
        const configExtension = configExtensionString ? JSON.parse(configExtensionString) : {};
        remoteAppConfig = deepMergeObjects(remoteAppConfig, configSpec.reverseTransform?.(configExtension) ?? configExtension);
    });
    return { ...remoteAppConfig };
}
function renderSuccessMessage(configFileName, remoteApp, localApp, useVersionedAppConfig) {
    renderSuccess({
        headline: `${configFileName} is now linked to "${remoteApp.title}" on Shopify`,
        body: `Using ${configFileName} as your default config.`,
        nextSteps: [
            [`Make updates to ${configFileName} in your local project`],
            [
                'To upload your config, run',
                {
                    command: formatPackageManagerCommand(localApp.packageManager, `shopify app ${useVersionedAppConfig ? 'deploy' : 'config push'}`),
                },
            ],
        ],
        reference: [
            {
                link: {
                    label: 'App configuration',
                    url: 'https://shopify.dev/docs/apps/tools/cli/configuration',
                },
            },
        ],
    });
}
//# sourceMappingURL=link.js.map